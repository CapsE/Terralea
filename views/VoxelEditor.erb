<html>
	<head>
		<link rel="shortcut icon" href="/Pics/Icon.ico" />
		<link href="style.css" rel="stylesheet">
		<script src="js/three.min.js"></script>
		<script src="js/loaders/JSONLoader.js"></script>
		<script src="js/loaders/TextureLoader.js"></script>
		<script src="js/exporter/GeometryExporter.js"></script>
		<script src="scripts/graphics.js" type="text/javascript"></script>
		<script src="scripts/cameraMove.js" type="text/javascript"></script>
		<script src="scripts/modelCreator.js" type="text/javascript"></script>
		<script src="scripts/SaveLoadModel.js" type="text/javascript"></script>
		<script src="js/jscolor/jscolor.js" type="text/javascript"></script>
		<style>canvas { width: 100%; height: 100%;}</style>
	</head>
	<body style="margin:0px; padding:0px;">		
		<div id="imageViewHolder" class="window" style="display:none; position:fixed; z-index:100; width:80%; left:10%;">
			<img id="imageView" src="icons/t_pipette.png" style="width:100%;"></img>
			<img id="imageViewClose" src="icons/redo.png" style="position:absolute; right:0px; top:0px; cursor:pointer; z-index:101;" onclick="closeScreenshot()"></img>
		</div>
		<div id="scene" style="float:left; width:100%;" onclick="Test()">
		
		</div>
		<div id="timeline" style="position:fixed; top:10px; left:44%; width:12%;">
			<div id="timeElement0" class="timeElement" data-i="0" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement1" class="timeElement" data-i="1" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement2" class="timeElement" data-i="2" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement3" class="timeElement" data-i="3" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement4" class="timeElement" data-i="4" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement5" class="timeElement" data-i="5" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement6" class="timeElement" data-i="6" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement7" class="timeElement" data-i="7" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement8" class="timeElement" data-i="8" data-active="false" onclick="timeLineClick(event)"></div>
			<div id="timeElement9" class="timeElement" data-i="9" data-active="false" onclick="timeLineClick(event)"></div>
		</div>
		<div id="toolbar" class="window" style="position:fixed; right:0px; width:18%;">
			<label for="name">Name:</label><input id="name" value="untitled" onfocus="disableMove()" onblur="enableMove()"></input><br><br>
			<input id="colorPicker" class="color" onblur="colorPicked()" onclick="PickingColor()"><br>
			<img id="pipette" src="icons/t_pipette.png" class="icon" onclick="Pipette()"></img>
			<img id="repaint" src="icons/tool_brush.png" class="icon" onclick="Repaint()"></img>
			<img id="replaceIcon" src="Pics/Replace.png" class="icon" onclick="Replace()"></img>
			<img id="cubeMode" src="icons/t_block.png" class="icon" onclick="CubeMode()"></img>
			<img id="double" src="Pics/Double.png" class="icon" onclick="Double()"></img>
			<img id="revert" src="icons/undo.png" class="icon" onclick="revertAction()"></img>
			<img id="revert" src="icons/redo.png" class="icon" onclick="forwardAction()"></img>
			<br>
			<div id="replace" style="display:none;">
				<input id="replacePicker" class="color" onblur="replacePicked()">
			</div>
			<br>
			<button id="safeButton" onclick="safe()">Save</button>
			<button id="loadButton" onclick="load()">Load</button>
			<button id="loadButton" onclick="exportModel()">Export</button>
			<button id="screenshotButton" onclick="screenShot()">Screenshot</button>
			<button id="resetButton" onclick="reset()" style="float:right; margin-right:5px;">Reset</button><br>
			<div id="colors" width="100%" height="400px" class="window" style="padding:0px; border-width:0.5px;">
				<div id="colorField" class="colorBox" style="display:none;" onclick="colorClicked(event)"></div>
			</div>
			<textarea id="safeCode" style="width:95%; height:200px; display:block;" align="top" onfocus="this.select()">
			
			</textarea>
		</div>
	</body>	
	
	<!-- Shader -->
	<script id="2d-vertex-shader" type="x-shader/x-vertex">
	uniform vec4 myCcolor;
	varying vec2 vUv;

	void main() {
	  vUv = uv;
	  gl_Position = projectionMatrix *
                  modelViewMatrix *
                  vec4(position,1.0);
	}
	</script>

	<script id="2d-fragment-shader" type="x-shader/x-fragment">
	uniform vec3 myColor;
	varying vec2 vUv;
	void main() {
		if(vUv[0] < 0.025 || vUv[1] < 0.025 || vUv[0] > 0.975 || vUv[1] > 0.975){
			gl_FragColor = vec4(myColor - vec3(0.2,0.2,0.2), 1.0);
		}else{
			gl_FragColor = vec4(myColor, 1.0);  // color
		}
	}
	</script>
	
	<script>
		var blocks = {};
		var colors = {};
		var usedColors = {};
		var pipette = false;
		var replace = false;
		var repaint = false;
		var cubeMode = false;
		var pickingColor = false;
		var cubeModeSelections = [];
		var actions = [];
		var actionCounter = 0;
		var toReplace;
		var center = new THREE.Vector3(0,0,0);
		var color = "FF0000";
		document.getElementById("colorPicker").value = color;
		var replace = parseInt(document.getElementById("replacePicker").value, 16);
		var imageData;
		var getImageData = true;
		var scene = new THREE.Scene();
		var camera = new THREE.PerspectiveCamera( 100, window.innerWidth / window.innerHeight, 0.1, 1000 );
		var renderer = new THREE.WebGLRenderer({antialias: true, preserveDrawingBuffer: false});
		renderer.setClearColor( 0xFFFFFF, 1);		
		
		var allGeometry = new THREE.BoxGeometry(1,1,1);
		for(var i =-5; i <= 5; i++){
			for(var h = -5; h <= 5; h++){
				makeBlock(i,h,0, 0x99B2B7);
			}
		}
		
		var projector = new THREE.Projector();
		var intersected;

		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );
		
		camera.position.z = 5;
		camera.lookAt(new THREE.Vector3(0,10,0));
		camera.useQuaternion = true;
		camera.up = new THREE.Vector3(0,0,1);
		
		var manager = new THREE.LoadingManager();
		var loader = new THREE.JSONLoader( manager );
		
		function render() { 
			requestAnimationFrame(render);
			renderer.render(scene, camera);
			if(getImageData == true){
				imgData = renderer.domElement.toDataURL();
				getImageData = false;
			}
		} 
		render();
		
		var geometry = new THREE.CubeGeometry( 1, 1, 1 );
		var material = new THREE.MeshBasicMaterial( { color: color, wireframe: true } );
		var previewCube = new THREE.Mesh( geometry, material );
		scene.add( previewCube );
		
	</script>
	<script>	
		function timeLineClick(e){
			var te = e.target;
			var c = parseInt(te.dataset.i)
			if(te.dataset.active == "true"){
				for(var i = 0; i < 10; i++){
					if(i > c){
						document.getElementById("timeElement" + i).style.backgroundColor = "white";
					}else{
						document.getElementById("timeElement" + i).style.backgroundColor = "blue";
					}
				}
				autoLoad(actions[c]);
			}
		}
		
		function screenShot(){
			previewCube.visible = false;
			getImageData = true;
			render();
			document.getElementById("imageViewHolder").style.display = "block";
			document.getElementById("imageView").src = imgData;
			previewCube.visible = true;
		}
		
		function closeScreenshot(){
			document.getElementById("imageViewHolder").style.display = "none";
		}
		
		function ClickCheck(event){
			
			var x = ( ( event.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width ) * 2 - 1;
			var y = - ( ( event.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height ) * 2 + 1;
			var vector = new THREE.Vector3(x, y, 0.5);

			var rayCaster = projector.pickingRay(vector, camera);

			var intersections = rayCaster.intersectObjects(scene.children, true);
			
			if ( intersections.length > 0 ) {
				if ( intersected != intersections[ 0 ].object ) {
					var n = intersections[0].face.normal;
					var x = Math.floor(intersections[0].object.position.x)
					var y = Math.floor(intersections[0].object.position.y)
					var z = Math.floor(intersections[0].object.position.z)
					
					//console.debug("Clicked: " + x + ", " + y + ", " + z);
					//console.debug("Normal: " + intersections[0].face.normal.x + ", " + intersections[0].face.normal.y + ", " + intersections[0].face.normal.z);
					if(pipette == true){
						if(colors[[x,y,z]] != null){
							color = colors[[x,y,z]];
							document.getElementById("colorPicker").value = color.toString(16);
							document.getElementById("colorPicker").focus();	
							document.getElementById("colorPicker").blur();	
							pipette = false;
							document.getElementById("pipette").src = "Pics/PipetteInActive.png";
						}
					}else if(repaint == true){
						removeBlock(x,y,z);
						addBlock(x,y,z, color);
					}else if(cubeMode == true){
						if(cubeModeSelections.length < 2){
							cubeModeSelections.push(intersections[0].object.position);
							//console.debug("added");
						}else{
							cubeModeSelections.push(intersections[0].object.position);
							var cm = cubeModeSelections;
							var xmin = [1000,-1000];
							var ymin = [1000,-1000];
							var zmin = [1000,-1000];
							for(var i = 0; i < cm.length; i++){
								if(cm[i].x < xmin[0]){
									xmin[0] = cm[i].x;
								}
								if(cm[i].x > xmin[1]){
									xmin[1] = cm[i].x;
								}
								if(cm[i].y < ymin[0]){
									ymin[0] = cm[i].y;
								}
								if(cm[i].y > ymin[1]){
									ymin[1] = cm[i].y;
								}
								if(cm[i].z < zmin[0]){
									zmin[0] = cm[i].z;
								}
								if(cm[i].z > zmin[1]){
									zmin[1] = cm[i].z;
								}
							}
							for(var dx = xmin[0]; dx <= xmin[1]; dx++){
								for(var dy = ymin[0]; dy <= ymin[1]; dy++){
									for(var dz = zmin[0]; dz <= zmin[1]; dz++){
										addBlock(dx,dy,dz, color);
									}
								}
							}
							actionPerformed();
							CubeMode();
						}
					}else{
						var p = previewCube.position;
						x = p.x;
						y = p.y;
						z = p.z;		
						addBlock(x,y,z, color);
						actionPerformed();
					}
					//center = new THREE.Vector3(x,y,z);
				}
			}
		}
		
		function RightClickCheck(event){
			actionPerformed()
			event.preventDefault();
			var x = ( ( event.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width ) * 2 - 1;
			var y = - ( ( event.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height ) * 2 + 1;
			var vector = new THREE.Vector3(x, y, 0.5);

			var rayCaster = projector.pickingRay(vector, camera);

			var intersections = rayCaster.intersectObjects(scene.children, true);
			
			if ( intersections.length > 0 ) {
				if ( intersected != intersections[ 0 ].object ) {
					if(intersections[0].object == previewCube){
						var toDelete = intersections[1];
					}else{
						var toDelete = intersections[0];
					}
					var x = toDelete.object.position.x;
					var y = toDelete.object.position.y;
					var z = toDelete.object.position.z;
					//console.debug("Clicked: " + x + ", " + y + ", " + z);
					removeBlock(x,y,z);
					actionPerformed()
				}
			}
		}
	</script>
	<script>
		renderer.domElement.onmousedown = function(event){CamMove(event);};
		document.body.onmouseup = function(event){CamStopMove(event);};
		renderer.domElement.addEventListener('mousemove', function(event){CalcDeltaPos(event);});
		renderer.domElement.addEventListener('contextmenu', function(ev){RightClickCheck(ev);});
		colorPicked();
		
		if (renderer.domElement.addEventListener) {
			// IE9, Chrome, Safari, Opera
			renderer.domElement.addEventListener("mousewheel", MouseWheelHandler, false);
			// Firefox
			renderer.domElement.addEventListener("DOMMouseScroll", MouseWheelHandler, false);
		}
		// IE 6/7/8
		else{
			renderer.domElement.attachEvent("onmousewheel", MouseWheelHandler);
		}

		CalcRotation();
		camera.lookAt(new THREE.Vector3(0,0,0));
		
		window.addEventListener( 'resize', onWindowResize, false );
		
		function addBlock(x,y,z,c){
			if(blocks[[x,y,z]] == null){
				blocks[[x,y,z]] = makeBlock(x,y,z, c);	
				colors[[x,y,z]] = c;
				c = c.toString(16);
				while(c.length < 6){
					c = "0" + c;
				}
				if(usedColors[c] == null){
					var palette = document.getElementById("colors");
					var colorField = document.getElementById("colorField").cloneNode(false);
					colorField.style.display = "block";
					colorField.style.backgroundColor = c;
					palette.appendChild(colorField);
					usedColors[c] = c;
					console.debug(c);
				}
			}
		}
		
		function PreviewBlock(event){
			var x = ( ( event.clientX - renderer.domElement.offsetLeft ) / renderer.domElement.width ) * 2 - 1;
			var y = - ( ( event.clientY - renderer.domElement.offsetTop ) / renderer.domElement.height ) * 2 + 1;
			var vector = new THREE.Vector3(x, y, 0.5);

			var rayCaster = projector.pickingRay(vector, camera);

			var intersections = rayCaster.intersectObjects(scene.children, true);
			
			if ( intersections.length > 0 ) {
				if ( intersected != intersections[ 0 ].object && intersections[0].object != previewCube ) {
					var n = intersections[0].face.normal;
					var x = Math.floor(intersections[0].object.position.x)
					var y = Math.floor(intersections[0].object.position.y)
					var z = Math.floor(intersections[0].object.position.z)
					if(repaint == false && pipette == false){
						x += n.x;
						y += n.y;
						z += n.z;
					}
					previewCube.position = new THREE.Vector3(x,y,z);
				}
			}
		}
		
		function removeBlock(x,y,z){
			var block = blocks[[x,y,z]];				
			scene.remove(block);
			blocks[[x,y,z]] = null;
			colors[[x,y,z]] = null;
		}
		
		function onWindowResize( e ) {
			var containerWidth = window.innerWidth *0.8;
			var containerHeight = window.innerHeight;
			renderer.setSize(containerWidth, containerHeight  );
			camera.aspect = containerWidth / containerHeight;
			camera.updateProjectionMatrix();
		}
		
		function colorClicked(e){
			var c =  rgb2hex(e.target.style.backgroundColor);
			document.getElementById("colorPicker").value = c;
			document.getElementById("colorPicker").focus();
			document.getElementById("colorPicker").blur();
			console.debug(c);
		}
		
		function PickingColor(){
			pickingColor = true;
		}
		
		function colorPicked(){
			color = parseInt(document.getElementById("colorPicker").value, 16);
			previewCube.material.color.setHex(color);
			pickingColor = false;
			//console.debug(color);
		}
		function replacePicked(){
			replace = parseInt(document.getElementById("replacePicker").value, 16);
			var keys = toReplace;
			for(var i = 0; i < keys.length; i++){
				colors[keys[i]] = replace;
				var k = keys[i].split(",");
				removeBlock(k[0], k[1], k[2]);					
				addBlock(k[0], k[1], k[2], replace);					
			}
			actionPerformed();
		}
		
		function getBlock(x,y,z){
			return blocks[x + "," + y + "," + z]
		}
		
		function actionPerformed(){
			if(actionCounter < actions.length -1){
				actions.splice(actionCounter +1, actions.length);
			}
			actions.push(autoSafe());
			actionCounter = actions.length -1;
			var te = document.getElementById("timeElement" + actionCounter)
			te.style.backgroundColor = "blue";
			te.dataset.active = true;
			if(actions.length >= 10){
				actions.shift();
			}
		}
		
		function revertAction(){
			actionCounter -= 1;
			if(actionCounter >= 0){
				autoLoad(actions[actionCounter]);
			}else{
				actionCounter = 0;
			}
		}
		
		function forwardAction(){
			actionCounter += 1;
			if(actionCounter < actions.length){
				autoLoad(actions[actionCounter]);
			}else{
				actionCounter = actions.length;
			}
		}
		
		function Pipette(){
			if(pipette == true){
				pipette = false;
				document.getElementById("pipette").src = "Pics/PipetteInActive.png";
			}else{
				pipette = true;
				document.getElementById("pipette").src = "Pics/PipetteActive.png";
			}
		}
		
		function Repaint(){
			if(repaint == true){
				repaint = false;
				document.getElementById("repaint").src = "Pics/tool_brush.png";
			}else{
				repaint = true;
				document.getElementById("repaint").src = "Pics/tool_brush_hl.png";
			}
			
		}
		
		function Replace(){
			if(replace == false){
				document.getElementById("replace").style.display = "block";
				replace = true;
				toReplace = [];
				var keys = Object.keys(blocks);
				for(var i = 0; i < keys.length; i++){
					if(colors[keys[i]] == color){
						toReplace.push(keys[i]);
					}
				}
			}else{
				replace = false;
				document.getElementById("replace").style.display = "none";
			}
		}
		
		function CubeMode(){
			if(cubeMode == false){
				cubeMode = true;
				cubeModeSelections = [];
				document.getElementById("cubeMode").src = "Pics/CubeActive.png";
			}else{
				cubeMode = false;
				document.getElementById("cubeMode").src = "Pics/Cube.png";
			}
		}
		
		function Double(){
			var newAr = {}
			var keys = Object.keys(blocks);
			for(var i = 0; i < keys.length; i++){
				if(colors[keys[i]] != null){
					var ar = keys[i].split(",");
					ar[0] = ar[0]*2;
					ar[1] = ar[1]*2;
					ar[2] = ar[2]*2;
					newAr[[parseInt(ar[0]) - 0, parseInt(ar[1]) - 0, parseInt(ar[2]) - 0]] = colors[keys[i]];
					newAr[[parseInt(ar[0]) - 1, parseInt(ar[1]) - 0, parseInt(ar[2]) - 0]] = colors[keys[i]];
					newAr[[parseInt(ar[0]) - 0, parseInt(ar[1]) - 1, parseInt(ar[2]) - 0]] = colors[keys[i]];
					newAr[[parseInt(ar[0]) - 1, parseInt(ar[1]) - 1, parseInt(ar[2]) - 0]] = colors[keys[i]];
					
					newAr[[parseInt(ar[0]) - 0, parseInt(ar[1]) - 0, parseInt(ar[2]) - 1]] = colors[keys[i]];
					newAr[[parseInt(ar[0]) - 1, parseInt(ar[1]) - 0, parseInt(ar[2]) - 1]] = colors[keys[i]];
					newAr[[parseInt(ar[0]) - 0, parseInt(ar[1]) - 1, parseInt(ar[2]) - 1]] = colors[keys[i]];
					newAr[[parseInt(ar[0]) - 1, parseInt(ar[1]) - 1, parseInt(ar[2]) - 1]] = colors[keys[i]];
				}
			}
			reset();
			//console.debug(newAr);
			var keys = Object.keys(newAr);
			for(var i = 0; i < keys.length; i++){
				var ar = keys[i].split(",");
				addBlock(ar[0], ar[1], ar[2], newAr[keys[i]]);
			}
			actionPerformed();
		}
	</script>
	<script>
		function moveAllBlocks(vector){
			var newAr = {}
			var keys = Object.keys(blocks);
			for(var i = 0; i < keys.length; i++){
				if(colors[keys[i]] != null){
					var ar = keys[i].split(",");
					newAr[[parseInt(ar[0]) + vector[0], parseInt(ar[1]) + vector[1], parseInt(ar[2]) + vector[2]]] = colors[keys[i]];
				}
			}
			reset();
			//console.debug(newAr);
			var keys = Object.keys(newAr);
			for(var i = 0; i < keys.length; i++){
				var ar = keys[i].split(",");
				addBlock(ar[0], ar[1], ar[2], newAr[keys[i]]);
			}
			actionPerformed();
		}
	</script>
	<script>
		function getFace(Vec1, Vec2){
			camera.position.x = Vec1.x;
			camera.position.y = Vec1.y;
			camera.position.z = Vec1.z;
			camera.lookAt(Vec2);
			
			var x = 0;
			var y = -0;
			var vector = new THREE.Vector3(x, y, 0.5);
			
			var rayCaster = projector.pickingRay(vector, camera);
			var intersections = rayCaster.intersectObjects(scene.children, true);
			
			if ( intersections.length > 0 ) {
				if ( intersected != intersections[ 0 ].object ) {
					var n = intersections[0].object.position;
					return n;
				}
			}
		}
		function exportToJson(){
			var a = getFace(new THREE.Vector3(10,0,1), new THREE.Vector3(-0.5,0,1));
			console.debug(a);
		}
	</script>
	<script>
		var modelId = "null";
		autoLoad("<%= @load.split("\n").join("\\n") %>");
		<% if params[:id] %>
			 modelId = <%= params[:id] %>;
		<% end %>
	</script>
</html>
